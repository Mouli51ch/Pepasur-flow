/**
 * StakingService.flow-evm.patch.js
 *
 * Patch showing the specific changes needed in StakingService.js for Flow EVM
 *
 * Apply these changes to your existing StakingService.js file.
 */

// ============================================
// CHANGE 1: Remove Aptos imports (line 1-2)
// ============================================

// BEFORE:
/*
const { Aptos, AptosConfig, Network, Account, Ed25519PrivateKey } = require("@aptos-labs/ts-sdk");
const crypto = require('crypto');
*/

// AFTER:
// ‚úÖ No Aptos imports needed anymore
const crypto = require('crypto');

// ============================================
// CHANGE 2: Constructor - Accept blockchain service (line 4-14)
// ============================================

// BEFORE:
/*
class StakingService {
  constructor() {
    this.stakeAmount = 100000; // 0.001 APT
    this.minPlayers = 4;
    this.totalPool = 400000; // 0.004 APT (4 players x 0.001 APT)
    this.stakedGames = new Map();
    this.playerStakes = new Map();
    this.aptos = null;
    this.account = null;
    this.initialize();
  }
*/

// AFTER:
class StakingService {
  constructor(blockchainService = null) {
    this.stakeAmount = 100000; // Keep for backward compatibility
    this.minPlayers = 4;
    this.totalPool = 400000;
    this.stakedGames = new Map();
    this.playerStakes = new Map();
    this.blockchainService = blockchainService; // ‚úÖ ADDED - Use injected blockchain service
    // ‚úÖ No more this.aptos or this.account
    // ‚úÖ No more initialize() call
  }

  // ============================================
  // CHANGE 3: Remove initialize() method (line 16-44)
  // ============================================

  // BEFORE:
  /*
  async initialize() {
    try {
      const network = process.env.NETWORK === 'mainnet' ? Network.MAINNET :
                      process.env.NETWORK === 'testnet' ? Network.TESTNET :
                      Network.DEVNET;

      const config = new AptosConfig({
        network,
        fullnode: process.env.APTOS_NODE_URL
      });
      this.aptos = new Aptos(config);

      if (process.env.SERVER_PRIVATE_KEY) {
        const privateKeyHex = process.env.SERVER_PRIVATE_KEY.replace('ed25519-priv-0x', '').replace('0x', '');
        const privateKey = new Ed25519PrivateKey(privateKeyHex);
        this.account = Account.fromPrivateKey({ privateKey });
        console.log('üîë Staking account initialized:', this.account.accountAddress.toString());
      }

      console.log('üí∞ Staking service initialized successfully on', network);
      console.log(`üí∞ Stake amount: ${this.stakeAmount / 100000000} APT per player`);
      console.log(`üí∞ Total pool: ${this.totalPool / 100000000} APT for 4 players`);
    } catch (error) {
      console.error('‚ùå Error initializing staking service:', error);
    }
  }
  */

  // AFTER:
  // ‚úÖ REMOVED - No longer needed, using injected blockchainService

  // ============================================
  // CHANGE 4: Update distributeRewards (line 289-329)
  // ============================================

  // BEFORE:
  /*
  async distributeRewards(gameId, rewards) {
    try {
      const aptosService = new (require('./AptosService'))();
      const winners = rewards.rewards.map((r) => r.playerAddress);
      const payoutAmounts = rewards.rewards.map((r) => BigInt(r.totalReceived));

      const txHash = await aptosService.submitSettlement(gameId, winners, payoutAmounts);

      const game = this.stakedGames.get(gameId);
      if (game) {
        game.status = 'completed';
        game.completedAt = Date.now();
      }

      const distributions = rewards.rewards.map((r) => ({
        playerAddress: r.playerAddress,
        role: r.role,
        stakeAmount: r.stakeAmount,
        rewardAmount: r.rewardAmount,
        totalReceived: r.totalReceived,
        stakeAmountInAPT: (parseInt(r.stakeAmount) / 100000000).toFixed(4),
        rewardInAPT: (parseInt(r.rewardAmount) / 100000000).toFixed(4),
        totalReceivedInAPT: (parseInt(r.totalReceived) / 100000000).toFixed(4),
      }));

      return {
        success: true,
        gameId: gameId,
        settlementTxHash: txHash,
        distributions: distributions,
        totalPool: rewards.totalPool,
        houseCut: rewards.houseCut,
        rewardPool: rewards.rewardPool,
      };
    } catch (error) {
      console.error('‚ùå Error distributing rewards:', error);
      throw error;
    }
  }
  */

  // AFTER:
  async distributeRewards(gameId, rewards) {
    try {
      console.log(`üí∞ distributeRewards called for game ${gameId}`);

      // ‚úÖ Check blockchain service availability
      if (!this.blockchainService || !this.blockchainService.isReady()) {
        throw new Error('Blockchain service not available or not ready');
      }

      // ‚úÖ Extract only winners (players with non-zero rewards)
      const winners = rewards.rewards
        .filter((r) => BigInt(r.totalReceived) > 0n)
        .map((r) => r.playerAddress);

      if (winners.length === 0) {
        throw new Error('No winners to distribute rewards to');
      }

      console.log(`üí∞ Settling game ${gameId} with ${winners.length} winners`);
      console.log(`üí∞ Winners:`, winners);
      console.log(`üí∞ Total pool: ${rewards.totalPool} wei`);
      console.log(`üí∞ Reward pool (after house cut): ${rewards.rewardPool} wei`);

      // ‚úÖ Call blockchain settlement (EvmServiceSimple.submitSettlement)
      // Note: PepasurSimple contract automatically calculates payouts
      const result = await this.blockchainService.submitSettlement(gameId, winners);

      if (!result.success) {
        throw new Error('Settlement transaction failed on blockchain');
      }

      console.log(`‚úÖ Settlement successful!`);
      console.log(`‚îú‚îÄ Transaction: ${result.transactionHash}`);
      console.log(`‚îú‚îÄ Block: ${result.blockNumber}`);
      console.log(`‚îî‚îÄ Gas used: ${result.gasUsed}`);

      // Update game status
      const game = this.stakedGames.get(gameId);
      if (game) {
        game.status = 'completed';
        game.completedAt = Date.now();
        game.settlementTx = result.transactionHash;
      }

      // ‚úÖ Format distributions for frontend (with FLOW conversion)
      const distributions = rewards.rewards.map((r) => ({
        playerAddress: r.playerAddress,
        role: r.role,
        stakeAmount: r.stakeAmount,
        rewardAmount: r.rewardAmount,
        totalReceived: r.totalReceived,
        // ‚úÖ Convert wei to FLOW for display using blockchain service method
        stakeAmountInFLOW: this.blockchainService.formatFlow(r.stakeAmount),
        rewardInFLOW: this.blockchainService.formatFlow(r.rewardAmount),
        totalReceivedInFLOW: this.blockchainService.formatFlow(r.totalReceived),
      }));

      return {
        success: true,
        gameId: gameId,
        settlementTxHash: result.transactionHash,
        blockNumber: result.blockNumber,
        gasUsed: result.gasUsed,
        explorerLink: `https://evm-testnet.flowscan.io/tx/${result.transactionHash}`, // ‚úÖ ADDED
        distributions: distributions,
        totalPool: rewards.totalPool,
        houseCut: rewards.houseCut,
        rewardPool: rewards.rewardPool,
      };
    } catch (error) {
      console.error('‚ùå Error distributing rewards:', error);
      console.error('Error details:', error.message);
      throw error;
    }
  }

  // ============================================
  // CHANGE 5: Update stakeForGame (line 97-164) - OPTIONAL
  // ============================================

  // BEFORE (line 129-130):
  /*
  const aptosService = new (require('./AptosService'))();
  const txHash = await aptosService.joinGame(gameId, playerAddress);
  */

  // AFTER - Option A (Recommended): Remove on-chain join from backend
  // In Flow EVM, players join games directly from frontend using MetaMask
  async stakeForGame(gameId, playerAddress, roomCode) {
    try {
      console.log(`üí∞ Player ${playerAddress} staking for game ${gameId}`);
      console.log(`‚ö†Ô∏è Note: Player must join game on-chain via frontend (MetaMask)`);

      if (!this.validateRoomCode(roomCode)) {
        throw new Error('Invalid room code');
      }

      if (!this.stakedGames.has(gameId)) {
        this.stakedGames.set(gameId, {
          roomCode: roomCode,
          players: [],
          totalStaked: 0,
          status: 'waiting',
          createdAt: Date.now()
        });
      }

      const game = this.stakedGames.get(gameId);

      if (game.players.includes(playerAddress)) {
        throw new Error('Player already staked for this game');
      }

      if (game.players.length >= this.minPlayers) {
        throw new Error('Game is full');
      }

      if (game.status !== 'waiting') {
        throw new Error('Game has already started');
      }

      // ‚úÖ Option A: Verify player joined on-chain (recommended)
      if (this.blockchainService && this.blockchainService.isReady()) {
        try {
          const onChainGame = await this.blockchainService.getGameInfo(gameId);
          if (!onChainGame.players.includes(playerAddress)) {
            throw new Error('Player has not joined game on-chain yet. Please join via frontend first.');
          }
          console.log(`‚úÖ Verified ${playerAddress} joined game ${gameId} on-chain`);
        } catch (error) {
          console.error('‚ùå Error verifying on-chain join:', error.message);
          throw new Error('Could not verify on-chain game join: ' + error.message);
        }
      }

      // Track player locally
      game.players.push(playerAddress);
      game.totalStaked += this.stakeAmount;

      this.playerStakes.set(`${gameId}-${playerAddress}`, {
        gameId: gameId,
        playerAddress: playerAddress,
        amount: this.stakeAmount,
        txHash: 'joined-via-frontend', // ‚úÖ Placeholder since join happens on frontend
        timestamp: Date.now(),
        status: 'staked'
      });

      console.log(`üí∞ Player tracked! Game ${gameId} now has ${game.players.length}/${this.minPlayers} players`);

      if (game.players.length === this.minPlayers) {
        game.status = 'full';
        console.log(`üéÆ Game ${gameId} is ready to start with full stake pool!`);
      }

      return {
        success: true,
        txHash: 'joined-via-frontend',
        amount: this.stakeAmount.toString(),
        gameStatus: game.status,
        playersCount: game.players.length,
        totalStaked: game.totalStaked.toString()
      };
    } catch (error) {
      console.error('‚ùå Error staking for game:', error);
      throw error;
    }
  }

  // ============================================
  // CHANGE 6: Update checkBalance (line 46-95) - OPTIONAL
  // ============================================

  // BEFORE:
  /*
  async checkBalance(playerAddress) {
    try {
      if (!this.aptos) {
        // mock balance
      }
      // Use Aptos SDK to get balance
      const balance = await this.aptos.getAccountAPTAmount({ accountAddress: playerAddress });
      // ...
    }
  }
  */

  // AFTER:
  async checkBalance(playerAddress) {
    try {
      console.log(`üí∞ Checking FLOW balance for ${playerAddress}`);

      if (!this.blockchainService || !this.blockchainService.isReady()) {
        console.log('‚ö†Ô∏è Blockchain service not ready, using mock balance');
        return {
          balance: "1000000000000000000", // 1 FLOW
          balanceInFLOW: "1.0",
          sufficient: true,
          mock: true
        };
      }

      // ‚úÖ Use EVM provider to get balance
      const provider = this.blockchainService.provider;
      const balance = await provider.getBalance(playerAddress);

      console.log(`üí∞ Player ${playerAddress} balance: ${this.blockchainService.formatFlow(balance)} FLOW`);

      return {
        balance: balance.toString(),
        balanceInFLOW: this.blockchainService.formatFlow(balance),
        sufficient: balance >= BigInt(this.stakeAmount)
      };
    } catch (error) {
      console.error('‚ùå Error checking balance:', error);
      throw error;
    }
  }

  // ============================================
  // All other methods remain the same:
  // - getGameStakingInfo()
  // - getPlayerStakeInfo()
  // - calculateRewards()
  // - validateRoomCode()
  // - getAllStakedGames()
  // - cleanupCompletedGames()
  // ============================================
}

module.exports = StakingService;

// ============================================
// SUMMARY OF CHANGES
// ============================================

/*
File: StakingService.js

Required changes:
1. Line 1-2: Remove Aptos SDK imports
2. Line 4-14: Update constructor to accept blockchainService
3. Line 16-44: REMOVE initialize() method entirely
4. Line 289-329: Completely rewrite distributeRewards()

Optional changes (recommended):
5. Line 97-164: Update stakeForGame() to verify on-chain joins
6. Line 46-95: Update checkBalance() to use EVM provider

Total changes: 4 required, 2 optional
Estimated time: 10-15 minutes
Complexity: Medium (mainly replacing Aptos SDK calls with EVM calls)
*/

// ============================================
// KEY DIFFERENCES: APTOS VS FLOW EVM
// ============================================

/*
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Aspect                   ‚îÇ Aptos (Old)              ‚îÇ Flow EVM (New)           ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ SDK                      ‚îÇ @aptos-labs/ts-sdk       ‚îÇ ethers.js                ‚îÇ
‚îÇ Private Key Format       ‚îÇ ed25519-priv-0x...       ‚îÇ 0x... (ECDSA)            ‚îÇ
‚îÇ Balance Check            ‚îÇ getAccountAPTAmount()    ‚îÇ provider.getBalance()    ‚îÇ
‚îÇ Settlement Function      ‚îÇ submitSettlement(        ‚îÇ submitSettlement(        ‚îÇ
‚îÇ                          ‚îÇ   gameId, winners,       ‚îÇ   gameId, winners        ‚îÇ
‚îÇ                          ‚îÇ   payouts, signature)    ‚îÇ )                        ‚îÇ
‚îÇ Settlement Auth          ‚îÇ ED25519 signature        ‚îÇ Owner-only modifier      ‚îÇ
‚îÇ Payout Calculation       ‚îÇ Backend calculates       ‚îÇ Contract calculates      ‚îÇ
‚îÇ Currency Unit            ‚îÇ Octas (10^-8 APT)        ‚îÇ Wei (10^-18 FLOW)        ‚îÇ
‚îÇ Format Function          ‚îÇ Manual / 100000000       ‚îÇ ethers.formatEther()     ‚îÇ
‚îÇ Parse Function           ‚îÇ Manual * 100000000       ‚îÇ ethers.parseEther()      ‚îÇ
‚îÇ Join Game                ‚îÇ Backend calls SDK        ‚îÇ Frontend calls MetaMask  ‚îÇ
‚îÇ Transaction Hash         ‚îÇ 64-char hex              ‚îÇ 66-char hex (0x...)      ‚îÇ
‚îÇ Explorer                 ‚îÇ explorer.aptoslabs.com   ‚îÇ evm-testnet.flowscan.io  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
*/

// ============================================
// TESTING YOUR CHANGES
// ============================================

/*
1. Update all three files:
   - server.js (or copy examples/server.flow-evm.js)
   - GameManager.js (apply changes from this file)
   - StakingService.js (apply changes from this file)

2. Ensure .env is configured:
   PEPASUR_CONTRACT_ADDRESS=0x54Fb33115B4b39A40A7267aEB69d2aBBA103Be1c
   IS_SIMPLE_CONTRACT=true
   SERVER_PRIVATE_KEY=0xaf0e3c0f38439b5347fdf62b609f1cbcfa2b892a9a4d34da14cf2e8729dda421
   FLOW_EVM_RPC_URL=https://testnet.evm.nodes.onflow.org
   CHAIN_ID=545

3. Start server:
   npm run dev

4. Expected startup logs:
   üî∑ Initializing EVM Service for Flow Testnet...
   üîë Owner wallet initialized: 0x798b32BDf86253060d598038b1D77C98C36881D6
   ‚úÖ Contract loaded successfully
   ‚úÖ EVM Service initialized successfully
   üí∞ Staking service using injected blockchain service
   üöÄ ASUR Backend server running on 0.0.0.0:3001
   üì° Socket.IO server ready for connections

5. Create and complete a test game to verify settlement works:
   - Create game via API or frontend
   - Simulate game completion
   - Verify settlement transaction on FlowScan
   - Check that winners can withdraw

6. Common errors and fixes:
   ‚ùå "Blockchain service not available"
      ‚Üí Ensure EvmServiceSimple is passed to GameManager constructor

   ‚ùå "Not owner" on settlement
      ‚Üí Verify SERVER_PRIVATE_KEY matches contract owner

   ‚ùå "Game not in progress"
      ‚Üí Check game status on-chain before settling

   ‚ùå "Cannot find module 'ethers'"
      ‚Üí Run: npm install ethers@^6.8.1
*/
